package Coordinator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

/**
 * Created by ohlbach on 12.09.2018.<br/>
 * A ChangeBlock is generated by CentralData. It contains the changes (unit clauses and implications) since
 * the last processing of the incoming information.
 * A ChangeBlock can be accessed by the Solvers to update their internal data structures.
 */
public class ChangeBlock {
    private ArrayList<Integer> oneLiteralClauses = null;
    private HashMap<Integer,TreeSet<Integer>> implications = null;

    /** adds a new unit clause.
     * Previously inserted implications are reduced by the new unit clause.
     *
     * @param literal a derived unit clause
     */
    public void addOneLiteralClause(int literal) {
        if(oneLiteralClauses == null) {oneLiteralClauses = new ArrayList<>();}
        assert !oneLiteralClauses.contains(literal) && !oneLiteralClauses.contains(-literal);
        oneLiteralClauses.add(literal);
        if(implications == null) {return;}
            for(int sign = -1; sign <= +1; sign += 2) {
                TreeSet<Integer> implicants = implications.get(sign*literal);
                if(implicants != null) {implications.remove(sign*literal);}
                for(Map.Entry<Integer,TreeSet<Integer>> map : implications.entrySet()) {
                    map.getValue().remove(sign*literal);}}}


    /** adds a new implication (premise -&gt> implicants
     *
     * @param premise    the premise of the implication
     * @param implicants the implied literals
     */
    public void addImplication(int premise, TreeSet<Integer> implicants) {
        if(implications == null) {implications = new HashMap<>();}
        TreeSet<Integer> implicant = implications.get(premise);
        if(implicant == null) {implications.put(premise,implicants);}
        else {implicant.addAll(implicants);}}

    /** gets all unit clauses.
     * The list MUST NOT be changed, because it may be shared by several threads
     *
     * @return the unit clauses.
     */
    public ArrayList<Integer> getOneLiteralClauses() {return oneLiteralClauses;}

    /** gets all implications.
     * The list MUST NOT be changed, because it may be shared by several threads
     *
     * @return the implications.
     */
    public HashMap<Integer,TreeSet<Integer>> getImplications() {return implications;}

    /** generates a String representation of the block.
     *
     * @return a String representation of the block.
     */
    public String toString() {
        StringBuilder st = new StringBuilder();
        if(oneLiteralClauses != null) {st.append("Units: ").append(oneLiteralClauses.toString()).append("\n");}
        if(implications != null) {
            for(Map.Entry<Integer,TreeSet<Integer>> entry : implications.entrySet()) {
                st.append(entry.getKey()).append(" -> ").append(entry.getValue().toString()).append("\n");}}
        return st.toString();}

}
