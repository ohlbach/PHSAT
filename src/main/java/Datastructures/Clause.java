package Datastructures;

import Datastructures.Clauses.Quantifier;
import Datastructures.Results.Unsatisfiable;
import InferenceSteps.*;
import Utilities.BiConsumerWithUnsatisfiable;
import Utilities.Utilities;
import it.unimi.dsi.fastutil.ints.IntArrayList;

import java.util.ArrayList;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntPredicate;

/**
 * Represents a Clause in a logic system.
 * <P>
 * The clause extends LinkedItem and can therefore be part of a doubly connected linked list.
 *
 */
public class Clause extends LinkedItem implements Cloneable {

    /** the maximal number of predicates where simplification by investigating all its models is still feasible. */
    private static final int maxModelSize = 12;
    /** the original input clause */
    public int[] inputClause;
    /** the identifier for the clause. */
    public int id;
    /** the version number (for simplified clauses) */
    public int version;
    /** the quantifier */
    public Quantifier quantifier;
    /** the lower limit for Interval clauses. */
    public int min;
    /** the upper limit for Interval clauses. */
    public int max;
    /** the sum of all multiplicities of the predicates. */
    public int expandedSize;

    /** the list of all Literal objects in the clause. */
    public ArrayList<Literal> literals = new ArrayList<>();

    /** null or a list of inference steps */
    public ArrayList<InferenceStep> inferenceSteps = null;

    /** indicates that there are multiplicities &gt; 1 */
    public boolean hasMultipleLiterals = false;

    /** for algorithms like subsumption test */
    public int timestamp = 0;

    /**Initializes a new Clause object.
     * <br>
     * multiple occurrences or predicates are comprised into one Literal object.<br>
     * Complementary predicates are removed, except for AND and EQUIV clauses.<br>
     * The resulting clause may be a tautology or unsatisfiable.
     *
     * @param inputClause           the input clause as generated by the Generator classes.
     * @param literalConstructor    the function to construct a Literal object from a literal
     */
    public Clause(int[] inputClause, boolean trackReasoning, Function<Integer,Literal> literalConstructor) {
        this.inputClause = inputClause;
        id = inputClause[0];
        quantifier = Quantifier.getQuantifier(inputClause[1]);
        assert(quantifier != null);
        int firstLiteralIndex = quantifier.firstLiteralIndex;
        expandedSize = inputClause.length-firstLiteralIndex;
        switch(quantifier) {
            case OR:       min = 1;              max = expandedSize;   break;
            case ATLEAST:  min = inputClause[2]; max = expandedSize;   break;
            case ATMOST:   min = 0;              max = inputClause[2]; break;
            case EXACTLY:  min = inputClause[2]; max = min;            break;
            case INTERVAL: min = inputClause[2]; max = inputClause[3]; break;
            case EQUIV:
            case AND:      min = expandedSize;   max = expandedSize;   break;
        }
        literals = new ArrayList<>(expandedSize);
        for (int i = firstLiteralIndex; i < inputClause.length; i++) {
            int literal = inputClause[i];
            boolean multiple = false;
            for(Literal literalObject : literals) {
                if(literal == literalObject.literal) {
                    ++literalObject.multiplicity;
                    multiple = true;
                    break;}
                if(quantifier != Quantifier.AND && quantifier != Quantifier.EQUIV && literal == -literalObject.literal) {
                    --min; --max;
                    --literalObject.multiplicity;
                    if(literalObject.multiplicity == 0) literals.remove(literalObject);
                    multiple = true; break;}}
            if(!multiple) {
                Literal literalObject = literalConstructor.apply(literal);
                literalObject.clause = this;
                literals.add(literalObject);}}

        expandedSize = 0;
        for(Literal literalObject : literals) expandedSize += literalObject.multiplicity;

        min = Math.max(0,min);
        if(min > 0 && max == expandedSize) {
            expandedSize = 0;
            for(Literal literalObject : literals) {
                literalObject.multiplicity = Math.min(min, literalObject.multiplicity);
                expandedSize += literalObject.multiplicity;}}
        max = Math.min(max,expandedSize);
        classifyQuantifier();
        hasMultipleLiterals = false;
        if(quantifier != Quantifier.OR) checkMultiplicities();
        if(trackReasoning) {
            inferenceSteps = new ArrayList<>();
            inferenceSteps.add(new InfInputClause(inputClause, this, "Clause"));}}

    /**
     * Constructs a Clause object with the given parameters.
     *
     * @param id the id of the clause
     * @param version the version of the clause
     * @param quantifier the quantifier of the clause
     * @param min the minimum value of the clause
     * @param max the maximum value of the clause
     * @param expandedSize the expanded size of the clause
     */
    public Clause(int id, int version, Quantifier quantifier, int min, int max, int expandedSize) {
        this.id = id;
        this.version =version;
        this.quantifier =quantifier;
        this.min =min;
        this.max =max;
        this.expandedSize = expandedSize;}


    /**
     * Classify the quantifier based on the values of min and max.
     * Possible quantifiers are EXACTLY, ATLEAST, ATMOST, and INTERVAL.
     * If min is equal to max, the quantifier is set to EXACTLY.
     * If max is equal to the expandedSize, the quantifier is set to ATLEAST or OR (depending on min).
     * If min is equal to 0, the quantifier is set to ATMOST.
     * Otherwise, the quantifier is set to INTERVAL.
     */
    public void classifyQuantifier() {
        if(quantifier == Quantifier.AND || quantifier == Quantifier.EQUIV) return;
        if(min == max) {quantifier = Quantifier.EXACTLY; return;}
        if(max == expandedSize) {
            quantifier = (min == 1) ? Quantifier.OR : Quantifier.ATLEAST;
            return;}
        if(min == 0) {quantifier = Quantifier.ATMOST; return;}
        quantifier = Quantifier.INTERVAL;}

    /**
     * Checks if the predicates list is empty.
     *
     * @return true if the predicates list is empty, false otherwise.
     */
    public boolean isEmpty() {
        return literals.isEmpty();}

    /** finds the Literal with the given literal.
     *
     * @param literal a literal.
     * @return null or a Literal with the given literal.
     */
    public Literal findLiteral(int literal) {
        for(Literal literalObject : literals) {
            if(literalObject.literal == literal) return literalObject;}
        return null;}

    /** finds the Literal with the given predicate.
     *
     * @param literal a literal.
     * @return null or a Literal with the given predicate.
     */
    public Literal findPredicate(int literal) {
        int predicate = Math.abs(literal);
        for(Literal literalObject : literals) {
            if(Math.abs(literalObject.literal) == predicate) return literalObject;}
        return null;}



    /**
     * Simplifies a clause recursively based on various conditions and rules.
     *
     * @param trackReasoning   Flag indicating whether reasoning should be tracked.
     * @param literalRemover   Consumer for removing predicates.
     * @param reportTruth      BiConsumer for reporting truth.
     * @param monitor          Consumer for monitoring progress.
     * @param symboltable      Symboltable containing symbols and their values.
     * @return Result indicating the simplification outcome:
     *                           1: The clause is simplified to a true clause.
     *                           0: No further simplification is possible.
     *                          -1: The clause is simplified to a false clause.
     */
    public int simplify(boolean trackReasoning, Consumer<Literal> literalRemover,
                        BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth, Consumer<String> monitor, Symboltable symboltable)
        throws Unsatisfiable {
        if(quantifier == Quantifier.AND || quantifier == Quantifier.EQUIV) {
            for(int i = 0; i < literals.size(); ++i) {
                int literal = literals.get(i).literal;
                for(int j = i + 1; j < literals.size(); ++j) {
                    if(literal == -literals.get(j).literal) return -1;}}} // clause is false
        switch(quantifier) {
            case AND:
                int[] clone = simpleClone();
                for(Literal literalObject : literals) {
                    int literal = literalObject.literal;
                    InferenceStep step = trackReasoning ? new InfTrueLiteralFromClause(clone,inferenceSteps, literal, "Clause") : null;
                    reportTruth.accept(literal,step);}
                return 1;
            case EQUIV:
                if(literals.size() == 1) return 1;
                return 0;}
        if(min == 0 && max == expandedSize) return 1;
        int versionBefore = version;
        int result;
        if(trackReasoning) {
            int[] clone = simpleClone();
            result = simplifyRecursively(trackReasoning, literalRemover,
                    (literal,inferenceStep) -> {reportTruth.accept(literal,inferenceStep);},
                    monitor,symboltable);
            if(result == -1) {addInferenceStep(new InfClauseSimplification(clone,null, "Clause")); return result;}
            if(result == 1 || versionBefore == version) return result;
            addInferenceStep(new InfClauseSimplification(clone,this, "Clause"));}
        else result = simplifyRecursively(trackReasoning, literalRemover, reportTruth, monitor,symboltable);
        checkMultiplicities();
        if(quantifier == Quantifier.ATMOST) invertAtmostClause();
        return result;}

    /**
     * Simplifies a clause recursively based on various conditions and rules.
     *
     * @param trackReasoning   Flag indicating whether reasoning should be tracked.
     * @param literalRemover   Consumer for removing predicates.
     * @param reportTruth      BiConsumer for reporting truth.
     * @param monitor          Consumer for monitoring progress.
     * @param symboltable      Symboltable containing symbols and their values.
     * @return Result indicating the simplification outcome:
     *                           1: The clause is simplified to a true clause.
     *                           0: No further simplification is possible.
     *                          -1: The clause is simplified to a false clause.
     */
    public int simplifyRecursively(boolean trackReasoning, Consumer<Literal> literalRemover,
                                   BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth, Consumer<String> monitor, Symboltable symboltable)
            throws Unsatisfiable {
        if(min <= 0 && max >= expandedSize) return 1; // true clause, e.g. [0,0] empty
        if(max < min || min > expandedSize) return -1;  // false clause, e.g. [1,1] empty (false literal removed from unit clause)

        int sign = 0;
        if(quantifier == Quantifier.AND || (min == expandedSize)) {sign = 1;}
        else {if (max == 0) sign = -1;}

        if(sign != 0) {
            String truth = sign == 1 ? " are true" : " are false";
            if(monitor != null) monitor.accept("All predicates in clause " + toString(symboltable,0) + truth);
            for(Literal literalObject : literals) {
                int literal = sign*literalObject.literal;
                InferenceStep step = trackReasoning ? new InfTrueLiteralFromClause(simpleClone(),inferenceSteps, literal,"Clause") : null;
                reportTruth.accept(literal,step);} // all predicates have a truth value.
            return 1;}

        if(quantifier == Quantifier.OR) return 0;  // no further simplification possible.

        if(literals.size() > maxModelSize) {
            if(monitor != null) {monitor.accept("Clause " + toString(symboltable,0) +
                    " has more than " + maxModelSize + " literals. Simplification may become incomplete.");}
            return 0;}

        IntArrayList models = getModels(monitor,symboltable);

        if(models.isEmpty()) return -1; // unsatisfiable clause [3,3] p^2,q^2

        if(models.size() == 1) { // [3,3] p,-q,r
            singletonModel(models.getInt(0), trackReasoning,reportTruth,monitor,symboltable);
            return 1;}

        if(extractTrueLiterals(models,trackReasoning, literalRemover, reportTruth, monitor, symboltable))
            return simplifyRecursively(trackReasoning, literalRemover, reportTruth, monitor, symboltable);

        if(extractIrrelevantLiterals(models,literalRemover, monitor, symboltable))
            return simplifyRecursively(trackReasoning, literalRemover, reportTruth, monitor, symboltable);

        if(divideByGCD(monitor,symboltable))
            return simplifyRecursively(trackReasoning, literalRemover, reportTruth, monitor, symboltable);

        return 0;
    }

    /** counts the number of true literals in the clause (incl. multiplicities)
     *
     * @param model maps a literal to true/false
     * @return the number of true literals in the clause.
     */
    public int trueLiterals(IntPredicate model) {
        int trueLiterals = 0;
        for(Literal literalObject : literals) {
            int literal = literalObject.literal;
            if(model.test(literal)) trueLiterals += literalObject.multiplicity;}
        return trueLiterals;}


    /** Computes the list of models for the clause.
     * <p>
     *  A model is an integer where bit i=1 means the i-th literal is true. <br>
     *  Example: clause p,q,r,-s: i = 1 means true(p),false(q,r,-s). i = 3 means true(p,q), false(r,-s).<br>
     *  As a side effect: the min- and max-values are narrowed according to the extreme values of all models.<br>
     *  Example: [1,3] p^2,q^2 -&gt; =2 p^2,q^2
     *
     * @return An IntArrayList containing the models for the clause.
     */
    protected IntArrayList getModels(Consumer<String> monitor, Symboltable symboltable) {
        IntArrayList models = new IntArrayList();
        int nModels = 1 << literals.size();
        int minValue = Integer.MAX_VALUE;
        int maxValue = 0;
        for (int model = 0; model < nModels; ++model) {
            int trueLiterals = 0;
            for (int j = 0; j < literals.size(); j++) {
                Literal literalObject = literals.get(j);
                int literal = literalObject.literal;
                if((literal > 0 && ((model & (1 << j)) != 0)) || (literal < 0 && ((model & (1 << j)) == 0)))
                        trueLiterals += literalObject.multiplicity;}
            if(min <= trueLiterals && trueLiterals <= max) {
                models.add(model);
                minValue = Math.min(minValue,trueLiterals);
                maxValue = Math.max(maxValue,trueLiterals);}}

        if(!models.isEmpty() && (min != minValue || max != maxValue)) {
            if(min != minValue) {
                if(monitor != null) monitor.accept("Clause "+ toString(symboltable,0) + ": min increased to " + minValue+
                        " because of models:\n" + modelsString(models,symboltable));
                min = minValue;
                expandedSize = 0;
                for(Literal literalObject : literals) {
                    literalObject.multiplicity = Math.min(min,literalObject.multiplicity);
                    expandedSize += literalObject.multiplicity;}}
            if(max != maxValue) {
                if(monitor != null) monitor.accept("Clause "+ toString(symboltable,0) + ": max reduced to " + maxValue+
                        " because of models:\n" + modelsString(models,symboltable));
                max = maxValue;}
            ++version;
            classifyQuantifier();}
        return models;}

    /**
     * Retrieves the models that satisfy the given clause with the specified predicates.
     *
     * @param clause     the array representing the clause
     * @param predicates the list of predicates
     * @return the list of models satisfying the clause
     */
    public static IntArrayList getModels(int[] clause, IntArrayList predicates) {
        IntArrayList models = new IntArrayList();
        int nModels = 1 << (clause.length - 5) / 2;
        for (int model = 0; model < nModels; ++model) {
            int trueLiterals = 0;
            for (int j = 5; j < clause.length; j+=2) {
                int literal = clause[j];
                int multiplicity = clause[j+1];
                if(Utilities.isTrue(model,literal,predicates)) trueLiterals += multiplicity;}
            if (clause[3] <= trueLiterals && trueLiterals <= clause[4]) models.add(model);}
        return models;}


    /**
     * Retrieves the models that satisfy the given clause with the specified predicates.
     *
     * @param predicates the list of predicates
     * @return the list of models satisfying the clause
     */
    public IntArrayList getModels( IntArrayList predicates) {
        IntArrayList models = new IntArrayList();
        int nModels = 1 << predicates.size();
        for (int model = 0; model < nModels; ++model) {
            int trueLiterals = 0;
            for (Literal literalObject : literals) {
                if(Utilities.isTrue(model,literalObject.literal,predicates)) trueLiterals += literalObject.multiplicity;}
            if (min <= trueLiterals && trueLiterals <= max) models.add(model);}
        return models;}



        /** Makes all predicates of a clause with a single model true.
         * <br>
         * Example: [3,3] p^2,-q  p and -q must be true.
         *
         * @param model           an integer representing the model, where bit i=1 means the i-th literal is true.
         * @param trackReasoning  a boolean indicating whether reasoning should be tracked.
         * @param reportTruth     a BiConsumer function for reporting truth.
         * @param monitor         a Consumer function for monitoring.
         * @param symboltable     a Symboltable object for symbol table operations.
         */
    protected void singletonModel(int model,boolean trackReasoning,
                                  BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth,
                                  Consumer<String> monitor, Symboltable symboltable) throws Unsatisfiable{
        int[] clone = trackReasoning ? simpleClone() : null;
        if(monitor != null) monitor.accept("Clause " + toString(symboltable,0) + " has single model: " + modelString(model,symboltable));
        for (int j = 0; j < literals.size(); j++) {
            int literal = Math.abs(literals.get(j).literal);
            if((model & (1 << j)) == 0) literal = -literal;
            InferenceStep step = trackReasoning ? new InfTrueLiteralFromClause(clone,inferenceSteps,literal,"Clause"): null;
            reportTruth.accept(literal,step);}}

    /**Extracts predicates which are true/false in all models of the clause.
     * <br>
     * Example: =2 1^3,2,3,4 -&gt; true(-1)
     *
     * @param models             the list of models to extract true predicates from
     * @param trackReasoning     a boolean indicating whether reasoning should be tracked
     * @param literalRemover     a function for removing predicates
     * @param reportTruth        a function for reporting truth
     * @param monitor            a function for monitoring
     * @param symboltable        the symbol table
     * @return true if any true predicates were extracted, false otherwise
     */
    protected boolean extractTrueLiterals(IntArrayList models,boolean trackReasoning,Consumer<Literal> literalRemover,
                                  BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth,
                                          Consumer<String> monitor, Symboltable symboltable) throws Unsatisfiable {
        int[] clone = trackReasoning ? simpleClone() : null;
        boolean changed = false;
        for(int j = literals.size()-1; j >= 0; --j) {
            int sign = sameInAllModels(models,j);
            if(sign == 0) continue;
            changed = true;
            int literal = sign*Math.abs(literals.get(j).literal);
            InferenceStep step = trackReasoning ? new InfTrueLiteralFromClause(clone, inferenceSteps, literal,"Clause"): null;
            if(monitor != null) {
                monitor.accept("Clause " + toString(clone,symboltable) + ": has true literal " + Symboltable.toString(literal,symboltable));}
            reportTruth.accept(literal,step);
            removeLiteralAtPosition(j, literal == literals.get(j).literal ? 1 : -1,literalRemover);
        }
        if(changed) {classifyQuantifier(); ++version;}
        return changed;}

    /**Extracts predicates whose truth is irrelevant for the truth of the clause.
     * <br>
     * Example: [2,3] p^2,q^2,r  -&gt; [2,3] p^2,q^2 (atleast one of p or q must be true, regardless of r)<br>
     * (-&gt; [2,2] p^2,q^2 -&gt; [1,2] p,q)
     *
     * @param models             the list of models to extract true predicates from
     * @param literalRemover     a function for removing predicates
     * @param monitor            a function for monitoring
     * @param symboltable        the symbol table
     * @return true if any of the predicates were extracted, false otherwise
     */
    protected boolean extractIrrelevantLiterals(IntArrayList models, Consumer<Literal> literalRemover,
                                          Consumer<String> monitor, Symboltable symboltable) {
        int mSize = models.size();
        if(mSize % 2 == 1) return false; // no irrelevant literal
        int mSize2 = mSize/2;

        boolean changed = false;
        for(int j = literals.size()-1; j >= 0; --j) {
            int mask = 1 << j;
            int counter = 0;
            boolean next = false;
            for(int model : models) {
                if((model & mask) == 0) {
                    ++counter;
                    if(counter > mSize2) {next = true; break;} // not irrelevant
                    boolean found = false;
                    for(int model1 : models) {
                        if((model1 & mask) != 0 && (model|mask) == model1) {found = true; break;}}
                    if(!found) {next = true; break;}}}
            if(next || counter != mSize2) continue;
            changed = true;
            if(monitor != null) monitor.accept("Clause " + toString(symboltable,0) +
                    " irrelevant literal " + Symboltable.toString(literals.get(j).literal,symboltable) + " removed");
            removeLiteralAtPosition(j, -1,literalRemover);}
        if(changed) {classifyQuantifier();++version;}
        return changed;}


    /** divides the limits and the multiplicities by their greatest common divisor.
     *
     * @param monitor          null or a monitor.
     * @param symboltable      null or a symboltable.
     * @return true if the clause is changed.
     */
    protected boolean divideByGCD(Consumer<String> monitor, Symboltable symboltable) {
        if(min <= 1 || max == 1) return false;
        int gcd = Utilities.gcd(min,max);
        if(gcd == 1) return false;

        for(Literal literalObject : literals) {
            gcd = Utilities.gcd(gcd,literalObject.multiplicity);
            if(gcd == 1) return false;}

        int[] clause = (monitor != null) ? simpleClone() : null;
        ++version;
        min /= gcd;
        max /= gcd;
        expandedSize = 0;
        for(Literal literalObject : literals) {
            literalObject.multiplicity /= gcd;
            expandedSize += literalObject.multiplicity;}
        classifyQuantifier();
        if(monitor != null) {monitor.accept("Clause " + toString(clause,symboltable)+
                " divided by GCD -> " + toString(symboltable,0));}
        return true;}

    /**
     * Inverts the clause if the quantifier is ATMOST and the maximum count is equal to the expanded size minus 1.
     * Changes the quantifier to OR and inverts each literal by multiplying it by -1.
     * Resets the minimum count to 1 and the maximum count to the expanded size.<br>
     * Example: atmost 4 p,q^2,r,s -&gt; -p,-q,-r,-s
     * <br>
     * Preconditions:
     * - The quantifier of the clause must be ATMOST.
     * - The maximum count of the clause must be equal to the expanded size minus 1.<br>
     */
    protected void invertAtmostClause() {
        assert quantifier == Quantifier.ATMOST;
        if(max == expandedSize-1) { // OR-Clauses are much simpler to handle than ATMOST-clauses.
            expandedSize = literals.size();
            min = 1;
            max = expandedSize;
            quantifier = Quantifier.OR;
            for(Literal literalObject : literals) {
                literalObject.literal *= -1;
                literalObject.multiplicity = 1;}
            hasMultipleLiterals = false;}
    }

    /** removes a literal from the clause.
     * <br>
     * Notice: the literalRemover is not applied to the literal to be removed.
     *
     * @param literal            the literal to be removed.
     * @param trackReasoning     controls generation of inference steps
     * @param status             +1: literal is true, -1: literal is false, 0: literal is singleton pure
     * @param literalRemover     null or a function to be applied to removed literals during simplification.
     * @param reportTruth        a function for reporting a true literal.
     * @param monitor            null or a monitor
     * @param symboltable        null or a symboltable
     * @return                   -1 if a contradiction is encountered, +1 if the clause can be removed, 0 otherwise.
     */
    public int removeLiteral(int literal, boolean trackReasoning, int status, Consumer<Literal> literalRemover,
                             BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth,
                             Consumer<String> monitor, Symboltable symboltable) throws Unsatisfiable {
        int[] cloned = (trackReasoning || monitor != null) ? simpleClone() : null;
        removeLiteral(literal,status,literalRemover);
        ++version;
        if(trackReasoning) addInferenceStep(new InfTrueLiteralToClause(-literal,null,cloned,this,"Clause"));
        if(monitor != null) {
            monitor.accept("From clause " + toString(cloned, symboltable) +
                    " literal " + Symboltable.toString(literal,symboltable) + " removed => "+
                    toString(symboltable,0));}
        return simplify(trackReasoning,literalRemover,reportTruth, monitor,symboltable);}

    /** removes a literal from an OR-clause (for example because of merge-resolution).
     * <br>
     * Notice: the literalRemover is not applied to the literal to be removed.
     *
     * @param literal            the literal to be removed.
     * @param trackReasoning     controls generation of inference steps
     * @param literalRemover     null or a function to be applied to removed literals.
     * @param reportTruth        null or a function for reporting a true literal (in case of a unit clause).
     * @return                   true if the clause can be removed (unit clause), false otherwise.
     */
    public boolean removeLiteral(int literal, boolean trackReasoning, Consumer<Literal> literalRemover,
                                 BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth) throws Unsatisfiable {
        assert quantifier == Quantifier.OR;
        for(int i = 0; i < literals.size(); ++i) {
            Literal literalObject = literals.get(i);
            if(literalObject.literal == literal) {
                ++version;
                literals.remove(i);
                if(literalRemover != null) literalRemover.accept(literalObject);
                break;}}
        if(literals.size() == 1) {
            Literal literalObject = literals.get(0);
            if (literalRemover != null) literalRemover.accept(literalObject);
            if(reportTruth != null) {
                InferenceStep step = trackReasoning ? new InfUnitClause(this,"Clause") : null;
                reportTruth.accept(literalObject.literal,step);
                return true;}}
        return false;}


    /**Removes th j-th literal from the list of predicates in the clause.
     * <p>
     * status = 1:  literal is true (decrease min and max) <br>
     * status = -1: literal is false (no change on min, max)<br>
     * status = 0:  literal is singleton pure (decrease only min) <br>
     * Updates the expandedSize and adjusts the multiplicities.
     * The quantifier is also updated.
     *
     * @param literal the literal to be removed
     * @param status  +1: literal is true; -1: literal is false; 0: literal is singleton pure
     * @return true if the literal has been removed.
     */
    public boolean removeLiteral(int literal, int status, Consumer<Literal> literalRemover) {
        int predicate = Math.abs(literal);
        for(int i = 0; i < literals.size(); ++i) {
            int lit = literals.get(i).literal;
            if(Math.abs(lit) == predicate) {
                removeLiteralAtPosition(i,lit == literal ? status : -status,literalRemover);
                return true;}}
        return false;}




    /**Removes th j-th literal from the list of predicates in the clause.
     * <p>
     * status = 1:  literal is true (decrease min and max) <br>
     * status = -1: literal is false (no change on min, max)<br>
     * status = 0:  literal is singleton pure (decrease only min) <br>
     * Updates the expandedSize and adjusts the multiplicities.
     * The quantifier is also updated.
     *
     * @param position       the index of the literal to be removed
     * @param status  +1: literal is true; -1: literal is false; 0: literal is singleton pure
     */
    public void removeLiteralAtPosition(int position, int status,Consumer<Literal> literalRemover) {
        Literal literalObject = literals.get(position);
        literals.remove(position);
        if(literalRemover != null) literalRemover.accept(literalObject);
        expandedSize -= literalObject.multiplicity;
        switch(status) {
            case 1: max -= literalObject.multiplicity;
            case 0: min = Math.max(0, min - literalObject.multiplicity);}
        if(min > 0 && max == expandedSize) {
            expandedSize = 0;
            for (Literal litObject : literals) {
                litObject.multiplicity = Math.min(min, litObject.multiplicity);
                expandedSize += litObject.multiplicity;}}
        max = Math.min(max,expandedSize);
        if(hasMultipleLiterals) {checkMultiplicities();}
        classifyQuantifier();}

    /** updates the hasMultipleLiterals flag.
     */
    private void checkMultiplicities() {
        hasMultipleLiterals = false;
        for(Literal litObject : literals) {
            if(litObject.multiplicity > 1) {
                hasMultipleLiterals = true;
                break;}}}

    /** replaces an old literal by a new literal.
     * Multiple occurrences and complementary predicates are treated, but no other simplifications are done.
     *
     * @param newLiteral the new literal
     * @param oldLiteral the old literal
     * @return true if the oldLiteral has been replaced.
     */
    public boolean replaceLiteral(int newLiteral, int oldLiteral) {
        int indexOld = Literal.indexOf(literals,oldLiteral);
        if(indexOld < 0) {
            indexOld = Literal.indexOf(literals,-oldLiteral);
            if(indexOld < 0) return false;
            newLiteral *= -1; oldLiteral *= -1;}

        int indexNew = Literal.indexOf(literals,newLiteral);
        if(indexNew >= 0) { // p,q,r and r -> p
            Literal newLitObject = literals.get(indexNew);
            newLitObject.multiplicity += literals.get(indexOld).multiplicity;
            literals.remove(indexOld);
            ++version;
            if(min > 0 && max == expandedSize && newLitObject.multiplicity > min) {
                expandedSize -= (newLitObject.multiplicity-min);
                max = expandedSize;
                newLitObject.multiplicity = min;}
            checkMultiplicities();
            classifyQuantifier();
            return true;}

        indexNew = Literal.indexOf(literals,-newLiteral);
        if(indexNew >= 0) { // p,q,r and r -> -p  newLiteral is already in the clause
            ++version;
            Literal newLitObject = literals.get(indexNew);
            Literal oldLitObject = literals.get(indexOld);
            int newMultiplicity = newLitObject.multiplicity; int oldMultiplicity = oldLitObject.multiplicity;
            if(newMultiplicity == oldMultiplicity) { // p^2,q,r^2 and r -> -p -> p^2,q,-p^2
                literals.remove(newLitObject); literals.remove(oldLitObject);
                min = Math.max(0,min-newMultiplicity);
                expandedSize -= 2*newMultiplicity;
                max = Math.min(expandedSize,max-newMultiplicity);
                checkMultiplicities();
                classifyQuantifier();
                return true;}
                                                                // old -> new
            if(newMultiplicity < oldMultiplicity) { // p,q,r^2 and (r -> -p) -> p,q,-p^2
                literals.remove(newLitObject);
                oldLitObject.multiplicity -= newMultiplicity;
                int multiplicity = oldMultiplicity - newMultiplicity;
                min = Math.max(0,min-multiplicity);
                expandedSize -= newMultiplicity + multiplicity;
                max = Math.min(expandedSize,max-multiplicity);
                checkMultiplicities();
                classifyQuantifier();
                return true;}
           // newMultiplicity > oldMultiplicity
            literals.remove(oldLitObject);
            newLitObject.multiplicity -= oldMultiplicity;
            int multiplicity = newMultiplicity - oldMultiplicity;
            min = Math.max(0,min-multiplicity);
            expandedSize -= oldMultiplicity + multiplicity;
            max = Math.min(expandedSize,max-multiplicity);
            checkMultiplicities();
            classifyQuantifier();
            return true;}

        literals.get(indexOld).literal = newLiteral;
        ++version;
        return true;}


    /** The method replaces the oldLiteral by the newLiteral literal.
     * <br>
     * newLiteral == oldLiteral must be part of an equivalence class.<br>
     * The oldLiteral is replaced by newLiteral and the clause is simplified.
     *
     * @param newLiteral         the representative literal of an equivalence class.
     * @param oldLiteral         the corresponding equivalent literal
     * @param equivalenceStep    the inference step that caused the equivalence
     * @param trackReasoning     controls generation of inference steps
     * @param literalRemover     null or a function to indicate that a literal is removed.
     * @param reportTruth        a function for reporting a true literal.
     * @param monitor            null or a monitor
     * @param symboltable        null or a symboltable
     * @return                   -1 if a contradiction is encountered, +1 if the clause can be removed, 0 otherwise
     */
    public int applyEquivalentLiteral(int newLiteral, int oldLiteral, InferenceStep equivalenceStep,
                                      boolean trackReasoning, Consumer<Literal> literalRemover,
                                      BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth,
                                      Consumer<String> monitor, Symboltable symboltable) throws Unsatisfiable {
        int[] cloned = (trackReasoning || monitor != null) ? simpleClone() : null;
        if(!replaceLiteral(newLiteral,oldLiteral)) return 0;
        if(trackReasoning) addInferenceStep(new InfApplyEquivalentLiteral(
                newLiteral, oldLiteral, equivalenceStep, cloned, this, "Clause"));
        if(monitor != null) {
            monitor.accept("In clause " + toString(cloned, symboltable) +
                    " literal " + Symboltable.toString(oldLiteral,symboltable) +
                    " replaced by " +  Symboltable.toString(newLiteral,symboltable) + " => " + toString(symboltable,0));}
        return simplify(trackReasoning,literalRemover,reportTruth, monitor,symboltable);
    }

    /**Applies a true/false literal to the clause, simplifying it by removing the corresponding literal and updating the clause properties.
     * <br>
     * Notice that the clause can become true or false.
     *
     * @param literal        The true/false literal to be applied to the clause.
     * @param isTrue         indicates whether the literal is true or false.
     * @param inferenceStep  which caused the truth/falsehood of the literal.
     * @param trackReasoning Indicates whether reasoning steps should be tracked.
     * @param monitor        The monitor used for printing information.
     * @param literalRemover to be applied to the removed literal.
     * @param reportTruth    to be applied to a true literal.
     * @param symboltable    The symbol table used for converting predicates to strings.
     * @return +1 if the clause can be removed, -1 if the clause became false, and 0 otherwise.
     */
    public int applyTrueLiteral(int literal, boolean isTrue, InferenceStep inferenceStep, boolean trackReasoning, Consumer<String> monitor,
                         Consumer<Literal> literalRemover, BiConsumerWithUnsatisfiable<Integer,InferenceStep> reportTruth,
                         Symboltable symboltable) throws Unsatisfiable {
        int[] clauseBefore = (trackReasoning || monitor != null) ? simpleClone() : null;
        if(!removeLiteral(literal,isTrue ? 1 : -1,literalRemover)) return 0;
        if(min <= 0 && max >= expandedSize) return 1;
         ++version;
        if(trackReasoning) {addInferenceStep(new InfTrueLiteralToClause(isTrue ? literal:-literal,inferenceStep,clauseBefore,this,"Clause"));}
        if(monitor != null)
            monitor.accept("true(" +Symboltable.toString(isTrue?literal:-literal,symboltable) + ") and " +
                            Clause.toString(clauseBefore,symboltable) + " -> " +
                            toString(symboltable,0) + " in " + Thread.currentThread().getName());
        if(literals.size() == 1) {
            InferenceStep step = trackReasoning ? new InfTrueLiteralFromClause(simpleClone(),
                    inferenceSteps,literals.get(0).literal,"Clause") : null;
            reportTruth.accept(literals.get(0).literal,step);
            return 1;}
        return simplify(trackReasoning,literalRemover,reportTruth,monitor,symboltable);}


    /** Add an inference step to the list of inference steps.
     *
     * @param step The inference step to be added.
     */
    public void addInferenceStep(InferenceStep step) {
        if(step != null) {
            if(inferenceSteps == null) inferenceSteps = new ArrayList<>();
            inferenceSteps.add(step);}}



    /** returns the number of Literal objects in the clause.
     *
     * @return the number of Literal objects in the clause.
     */
    public int size() {return literals.size();}

    /** returns the sum of the literal's multiplicities.
     *
     * @return the sum of the literal's multiplicities.
     */
    public int expandedSize() {return expandedSize;}



    /**
     * Creates and returns a clone of the Clause object.
     *
     * @return a new Clause object that is an identical copy of the original Clause.
     * @throws CloneNotSupportedException if the cloning operation is not supported for the Clause object.
     */
    public Clause clone() {
        try{Clause cloned = (Clause)super.clone();
            cloned.literals = new ArrayList<>(literals.size());
            for(Literal literalObject : literals) {
                cloned.literals.add(literalObject.clone(cloned));}
            return cloned;}
        catch(CloneNotSupportedException ex) {
            System.err.println(ex.toString());}
        return null;}

    /**
     * Creates a simple clone of the literal as an int-array: [id,version,quantifier,min,max,literal1,literal1.multiplicity,...]
     *
     * @return A clone of the literal with the essential information.
     */
    public int[] simpleClone() {
        int[] clone = new int[5+2*literals.size()];
        clone[0] = id;
        clone[1] = version;
        clone[2] = quantifier.ordinal();
        clone[3] = min;
        clone[4] = max;
        for(int i = 0; i < literals.size(); ++i) {
            clone[5+2*i]   = literals.get(i).literal;
            clone[5+2*i+1] = literals.get(i).multiplicity;}
        return clone;}

    /** collects the predicates of a simpleClone in an IntArray
     *
     * @param clauses a simple clone
     * @return the predicates of the clone in an IntArray.
     */
    public static IntArrayList predicates(int[]... clauses) {
        IntArrayList predicates = new IntArrayList();
        for(int[] clause : clauses) {
            for(int i = 5; i < clause.length; i+=2) {
                int predicate = Math.abs(clause[i]);
                if(!predicates.contains(predicate)) predicates.add(predicate);}}
        return predicates;}

    /** adds the predicates of a simpleClone to an IntArray
     *
     * @param clone a simple clone
     * @param predicates the list where the predicates are to be added.
     * @return the predicates of the clone in an IntArray.
     */
    public static void predicates(int[] clone, IntArrayList predicates) {
        for(int i = 5; i < clone.length; i+=2) {
            int predicate = Math.abs(clone[i]);
            if(!predicates.contains(predicate)) predicates.add(predicate);}}

    /** collects the predicates of the clauses in an IntArrayList
     *
     * @param clauses some clauses.
     * @return the predicates in an IntArrayList.
     */
    public static IntArrayList predicates(Clause... clauses) {
        IntArrayList predicates = new IntArrayList();
        for(Clause clause : clauses) {
            for(Literal literalObject : clause.literals) {
            int predicate = Math.abs(literalObject.literal);
                if(!predicates.contains(predicate)) predicates.add(predicate);}}
        return predicates;}

    /** collects the predicates of the clause in an IntArray
     *
     * @return the predicates of the clause in an IntArray.
     */
    public  IntArrayList predicates() {
        IntArrayList predicates = new IntArrayList(literals.size());
        for(Literal literalObject : literals) predicates.add(Math.abs(literalObject.literal));
        return predicates;}

    /**
     * Checks if clause1 is a subset of clause2.
     *
     * @param clause1 the first Clause object
     * @param clause2 the second Clause object
     * @return true if clause1 is a subset of clause2, false otherwise
     */
    public static boolean isSubset(Clause clause1, Clause clause2) {
        for(Literal literalObject : clause1.literals) {
            if(clause2.findLiteral(literalObject.literal) == null) return false;}
        return true;}

    /** checks if the clause is true in the model according to the sequence of predicates.
     * <br>
     * If a predicate p in the clause is not contained in the predicates then both true(p) and false(p) is considered.
     *
     * @param model  a model as a bitsequence
     * @param predicates a list of predicates
     * @return true if the clause is true in the model with the given predicates.
     */
    public boolean isTrue(int model, IntArrayList predicates) {
        int trueLiterals = 0;
        int extraLiterals = 0;
        for(Literal literalObject : literals) {
            int literal = literalObject.literal;
            if(predicates.contains(Math.abs(literal))) {
                if(Utilities.isTrue(model,literal,predicates)) trueLiterals += literalObject.multiplicity;}
            else extraLiterals += literalObject.multiplicity;}
        return min <= trueLiterals                      // extra literals are all false
                && trueLiterals + extraLiterals <= max; // extra literals are all true.
        }

    /** checks if the clause is true given the isTrue-function for predicates
     *
     * @param isTrue maps a literal to a truth-value.
     * @return true if the clause is true given this function.
     */
    public boolean isTrue(Function<Integer,Boolean> isTrue) {
        int trueLiterals = 0;
        for(Literal literalObject : literals) {
            if(isTrue.apply(literalObject.literal)) trueLiterals += literalObject.multiplicity;}
        return min <= trueLiterals && trueLiterals <= max;}

    /** checks if a simple clone is true given the isTrue-function,
     *
     * @param clone a simple clone
     * @param isTrue maps a literal to a truth-value
     * @return true if the clause is true.
     */
    public static boolean isTrue(int[] clone, Function<Integer,Boolean> isTrue) {
        int min = clone[3];
        int max = clone[4];
        int trueLiterals = 0;
        for(int i = 5; i < clone.length; i += 2) {
            if(isTrue.apply(clone[i])) trueLiterals += clone[i+1];}
        if(clone[2] == Quantifier.EQUIV.ordinal()) {
            return trueLiterals == 0 || trueLiterals == max;}
        return min <= trueLiterals && trueLiterals <= max;}

    /** checks if a simple clone is true in the given model.
     * <br>
     * The bits in the model must correspond to the literals in the clause.
     *
     * @param clause a simple clone
     * @param model a model represented as an int.
     * @return true if the clause is true.
     */
    public static boolean isTrue(int[] clause, int model) {
        int min = clause[3];
        int max = clause[4];
        int position = -1;
        int trueLiterals = 0;
        for(int i = 5; i < clause.length; i += 2) {
            ++position;
            int literal = clause[i];
            if(((literal > 0) ? ((model & (1 << position)) != 0) : ((model & (1 << position)) == 0))) trueLiterals += clause[i+1];}
        if(clause[2] == Quantifier.EQUIV.ordinal()) {
            return trueLiterals == 0 || trueLiterals == max;}
        return min <= trueLiterals && trueLiterals <= max;}
    /** checks if a simple clone is true in the given model.
     * <br>
     * The bits in the model must correspond to the literals in the clause.
     *
     * @param clause a simple clone
     * @param model a model represented as an int.
     * @return true if the clause is true.
     */
    public static boolean isTrue(int[] clause, int model, IntArrayList predicates) {
        int min = clause[3];
        int max = clause[4];
        int trueLiterals = 0;
        for(int i = 5; i < clause.length; i += 2) {
            int literal = clause[i];
            int position = predicates.indexOf(Math.abs(literal));
            if(((literal > 0) ? ((model & (1 << position)) != 0) : ((model & (1 << position)) == 0))) trueLiterals += clause[i+1];}
        if(clause[2] == Quantifier.EQUIV.ordinal()) {
            return trueLiterals == 0 || trueLiterals == max;}
        return min <= trueLiterals && trueLiterals <= max;}

    /**
     * Determines if the specified bit position has the same value in all models.
     *
     * @param models    the list of models to compare
     * @param position  the bit position to check
     * @return returns 1 if the specified bit position is set (1) in all models,
     *                  returns -1 if the specified bit position is unset (0) in all models,
     *                  returns 0 if the specified bit position has a mix of set and unset values in the models
     */
    public static int sameInAllModels(IntArrayList models, int position) {
        int model = models.getInt(0);
        int mask = 1 << position;
        boolean all1 = (model & mask) != 0;
        boolean all0 = !all1;

        for(int i = 1; i < models.size(); ++i) {
            model = models.get(i);
            boolean one = (model & mask) != 0;
            if((one && !all1) || (!one && !all0)) return 0;}
        if(all1) return 1;
        if(all0) return -1;
        return 0;}


    /**
     * Converts an int array representation of a clone to a string representation.
     *
     * @param clause the int array representation of a clone
     * @param symboltable the Symboltable object used for symbol lookup
     * @return the string representation of the clone
     */
    public static String toString(int[] clause,Symboltable symboltable) {
        String name = Integer.toString(clause[0]);
        if(clause[1] != 0) name += "."+clause[1];
        StringBuilder st = new StringBuilder();
        st.append(name).append(": ");
        Quantifier quantifier = Quantifier.getQuantifier(clause[2]);
        switch(Objects.requireNonNull(quantifier)) {
            case OR: break;
            case EQUIV:
            case AND:      st.append(quantifier.abbreviation).append(" "); break;
            case EXACTLY:
            case ATLEAST:  st.append(quantifier.abbreviation).append(clause[3]).append(" "); break;
            case ATMOST:   st.append(quantifier.abbreviation).append(clause[4]).append(" "); break;
            case INTERVAL: st.append("[").append(clause[3]).append(",").append(clause[4]).append("] ");}
        for(int i = 5; i < clause.length; i += 2) {
            int literal = clause[i]; int multiplicity = clause[i+1];
            st.append(Symboltable.toString(literal,symboltable));
            if(multiplicity > 1) st.append("^").append(multiplicity);
            if(i < clause.length-2)st.append(",");}
        return st.toString();}

    /**
     * Generates a string representation of the given model.
     * <br>
     * The bits in the model must correspond to the literals in the clause.
     *
     * @param model The integer representation of the model.
     * @param symboltable The given symbol table.
     * @return The string representation of the model.
     */
    public String modelString(int model, Symboltable symboltable) {
        StringBuilder st = new StringBuilder();
        for(int i = 0; i < literals.size(); ++i) {
            int sign = ((model & 1 << i) != 0) ? 1: -1;
            st.append(Symboltable.toString(sign*Math.abs(literals.get(i).literal) ,symboltable));
            if(i < literals.size()-1) st.append(",");}
        return st.toString();}

    /**
     * Generates a string representation of the given models.
     * <br>
     * The bits in the model must correspond to the literals in the clause.
     *
     * @param models The integer representation of the models.
     * @param symboltable The given symbol table.
     * @return The string representation of the model.
     */
    public String modelsString(IntArrayList models, Symboltable symboltable) {
        StringBuilder st = new StringBuilder();
        for(int model : models) {
            st.append(modelString(model,symboltable)).append("\n");}
        return st.toString();}

    /**
     * Generates a string representation of the given model.
     * <br>
     * The bits in the model must correspond to the given predicates.
     *
     * @param model The integer representation of the model.
     * @param predicates the corresponding predicates.
     * @param symboltable The given symbol table.
     * @return The string representation of the model.
     */
    public static String modelString(int model, IntArrayList predicates, Symboltable symboltable) {
        StringBuilder st = new StringBuilder();
        for(int i = 0; i < predicates.size(); ++i) {
            int sign = ((model & 1 << i) != 0) ? 1: -1;
            st.append(Symboltable.toString(sign*Math.abs(predicates.get(i)) ,symboltable));
            if(i < predicates.size()-1) st.append(",");}
        return st.toString();}

    /** returns the identifier + version (if != 0)
     *
     * @return the identifier + version (if != 0)
     */
    public String getName() {
        if(version == 0) return Integer.toString(id);
        return id+"."+version;}

    /** returns the identifier + version (if != 0)
     *
     * @param clause a simpleClone of the clause
     * @return the identifier + version (if != 0)
     */
    public static String getName(int[] clause) {
        int id = clause[0];
        int version = clause[1];
        if(version == 0) return Integer.toString(id);
        return id+"."+version;}

    /**
     * Returns a string representation of the clause without symboltable.
     *
     * @return the string representation of the clause
     */
    public String toString() {
        return toString(null,0);}

    /** turns the clause into a string.
     *
     * @param symboltable null or a symboltable.
     * @param size 0 or the length of the clause number string.
     * @return a string representation of the clause.
     */
    public String toString(Symboltable symboltable, int size) {
        String name = Integer.toString(id);
        if(version != 0) name += "."+version;
        StringBuilder st = new StringBuilder();
        st.append((size == 0) ? name : String.format("%"+size+"s",name)).append(": ");
        switch(quantifier) {
            case OR: break;
            case EXACTLY:
            case ATLEAST:  st.append(quantifier.abbreviation).append(min).append(" "); break;
            case ATMOST:   st.append(quantifier.abbreviation).append(max).append(" "); break;
            case INTERVAL: st.append("[").append(min).append(",").append(max).append("] ");}
        if(!literals.isEmpty()) {
            int length = literals.size()-1;
            for(int i = 0; i < length; ++i) {
                st.append(literals.get(i).toString(symboltable,0)).append(quantifier.separator);}
            st.append(literals.get(length).toString(symboltable,0));}
        return st.toString();}


}
